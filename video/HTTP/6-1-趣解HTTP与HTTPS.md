# 6-1-趣解 HTTP 与 HTTPS

## HTTP 静相依--安全的 HTTPS

## 什么是 HTTPS，它为什么安全？

## 开发人员小白的老板，要把全站都变为 https。

实际上 HTTP 和 HTTPS 可以算是两种不同的网络传输协议，虽然它们就差个字母，但是本质却大不相同，干万不能掉以轻心的。

了解他们之前，先回顾一下 HTTP 协议。

HTTP 协议，就是名字叫做超文本传输协议，位于 TCP/IP 四层模型当中的应用层，就是现在展示的最上面的这一层；
然后 HTTP 协议通过请求响应的方式，在客户端和服务端之间进行通信。

这一切看起来美好，但是 HTTP 有一个致命的缺点——不够安全。怎么不够安全呢？

因为 HTTP 协议的传输完全是以明文的方式，不做任何加密，相当于在网络上裸奔；这会导致什么问题？

## 讲个故事：

小风和小萌。
小风向小萌发送：“小萌，我喜欢你！”
由于传输信息是明文，这个信息有可能被某个中间人恶意拦截，甚至篡改，这种行为就叫做中间人攻击。

就像图里展示的一样，中间人通过截获请求的数据包，不但可以看还能够篡改，中间人改成了“小萌，我讨厌你！”，一下就搞黄了小风的表白。

别担心，我们可以对明文进行加密！

这里我们先普及一个概念，就是加密的概念。

加密算法一般情况下分为两种，一种叫对称加密，另外一种叫非对称加密；

所谓对称加密，也叫做密钥加密：就是指加密和解密使用的都是一个相同的密钥；

而非对称加密，也叫公钥加密，加密和解密使用了不同的密钥，比如说：谍战片、二次世界大战，抗日里的加密电报，世界大战里的各种沟通方式，其实都用到了一些加密的方程。

## 表白信息怎么加密？

小风和小萌可以事先约定好一种加密方式，并且约定好一种随机生成的密钥，这个密钥，小萌告诉小风，后续的通信里，信息的发送方，都使用密钥对着信息加密，而信息的接收方同样使用同一个密钥对信息进行解密，就像这样，小风先发送聊天请求，小萌直接回复给一个密钥，小风后边的信息和表白都通过这个密钥来加密之后再来发送，后边的信息都变成了这个样子：

XX*&$$%$###$
\*\*&&#￥%*##@

这样如果不知道密钥，即使获取到了信息，拦截到了信息，也没有办法解析和篡改。

这样是否绝对安全了呢？并不是。

虽然我们在后续的通讯中对明文进行了加密，但是第一次约定加密方式，约定加密方式之后的密钥的通信，仍然还是明文；

如果我们第一次通信时就已经被拦截了，那么密钥就会泄漏给中间人，中间人仍然可以解密后续所有的通信内容，怎么办？

我们可以使用刚刚提到的非对称加密，为密钥的传输做一层额外的捕获；

非对称加密的一组密钥中，包含一个公钥和一个私钥，明文既可以用公钥加密，用私钥解密，也可以用私钥加密，用公钥解密；

所以我们具体的操作方式，就变成了这个样子：

小风和小萌建立通信的时候，小萌首先把自己的公钥 KEY1 发送给小风，收到小萌的公钥以后，小风自己生成一个用于对称加密的密钥 KEY2，这个密钥为了后续聊天加密来任务，为了安全，我们不再直接明文约定，而是用刚才接收到的公钥 KEY1 对这个 KEY2 加密，得到了 VA3（value3），把这个发送给小萌；
小萌就可以用自己的非对称加密的私钥来解开公钥 KEY1 的加密，获得了 KEY2 的内容，接下来就可以用 KEY2 进行对称加密的通信；

所以，在这个通信过程中，即使中间人一开始就截获了公钥 KEY1，由于不知道私钥是什么，也没有办法去解密，我们想一下，这样是不是就能够确保安全了呢？

“流氓不可怕，就怕流氓有文化”，一般采取中间人攻击的是有文化的电脑高手。

结果就是：

在这种加密方式下，中间人又想到了另外一个坏主意：

中间人虽然不知道小萌的私钥是什么，但是他截获了小萌的公钥 KEY1 之后，可以偷天换日，自己另外生成一对公钥和私钥，把自己的公钥 KEY3 发给小风；小风不知道，公钥被偷偷改过，以为 KEY3 就是小萌的公钥；

然后，按照先前的流程，用 KEY3 加密了自己生成的对称加密的密钥 KEY2，发送给小萌，就是 VA4，这次通信再次被中间人（吐舌头的人，哈哈哈）再次截获；

他先用自己的私钥解开了 KEY3 的加密，获得了 KEY2，然后再用当初小红发过来的 KEY1 这个公钥，重新加密，又发给小萌，这样又得到一个 VA5；

这次，两个人的后续通信尽管还是一直在用 KEY2 做对称加密，但是中间人已经掌握了 KEY2；所以就可以轻松的解密，来获取你的内容了。

中间人实在是太狡猾了，还有什么其他的办法么？

新的解决方案：

这时，有必要引入一个第三方，这个第三方就是一个权威的证书颁发机构，CA 来解决。

到底什么是证书呢？

证书包含这么几个信息，包含证书的颁发机构，服务端的网址是什么，公钥（机构私钥加密）和证书签名（机构私钥加密）；当然，证书里还会有其他的一些信息，但是，为了便于说明，在这里做了简化，只列出这么一些关键信息；至于这些证书信息的用处，我们看看具体的通信流程，一般就能够大体搞明白了。

流程是这样：

首先，作为服务端的小萌，把自己的公钥 KEY1 发给证书办法机构，由证书颁发机构去申请证书，证书颁发机构自己也有一对公钥和私钥；

机构利用自己的私钥来加密 KEY1，并且通过服务端网址等信息生成一个证书签名；

证书签名同样经过了机构的私钥加密，这样制作完成了一个证书，机构把这个证书发送给了服务端小萌；

当后续小风再次向小萌请求通信时，小萌就不再返回自己的公钥了，而是直接把自己申请的证书返回给小风；

小风收到证书之后，要做的第一件事情就是，验证证书的真伪：

- 验证证书，解密获得公钥 KEY1
- 将准备进行对称加密的 KEY2
- 用公钥 KEY1 加密，加密结果为 VA3

。

这里，需要特别说明的是，各大浏览器和操作系统已经维护了所有权威证书机构的名称，和公钥。所以呢，小风只需要知道是哪个机构颁布的证书，就可以从本地找到对应的机构公钥，解密出证书的签名；

接下来，小风就可以按照同样的签名规则，自己也生成一个证书签名；

然后，如果两个签名是一致的，说明证书是有效的；验证成功以后呢，小风就可以放心的再次利用机构的公钥解密出服务端小萌的公钥 KEY1；

那这后面就跟之前一样了，小风生成自己对应的对称加密的密钥 KEY2，并且用服务端公钥 KEY1 加密 KEY2，发送给小萌；

最后呢，小萌还是用自己的私钥解密，得到对称加密的密钥 KEY2；于是两个人，可以开始用 KEY2 来进行对称加密的通信；

在这样一个流程下，中间人是否还有使坏的空间呢？

如果中间人自己，也向权威机构申请一个证书，并且把小萌发过来的证书，偷偷换成自己的证书呢？

其实对于这个，我们早有准备，因为证书的签名，是由服务端网址等等信息一起生成的，并且通过了机构的私钥加密，中间人也是没办法篡改的。

所以发给小风的假证书，肯定是没办法验证通过的，这就是我们 HTTPS 的主体思想。

所以呢，我们简单得出一个结论：HTTPS 是在 HTTP 的基础上增加的一个安全层；这一系列的认证、加密这个流程，都是在这个安全层当中完成的。

那么我们现在呢，先是对 HTTPS 原理有了一定的认识。

下一节用更官方，更概念原理的方式，让大家认识一下真正的 HTTPS。
