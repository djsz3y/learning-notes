/**
 * -------------------------------------------------
 * *一、掘金思路
 */

// --------------------------
// # 今天我对于防抖和节流的理解：

// 防抖是什么？防抖就是一次触发后，再次触发重新计时。
// 节流是什么？节流就是一次触发后，再次触发全部忽略。

// # 在实际应用中，要看需求是什么。

// 比如一个输入框，
// 多次输入请求服务端，想要的是最后一次输入请求服务端的结果。
// 再比如一个按钮提交操作，
// 多次提交请求服务端，想要的是第一次提交请求服务端的结果。

// # 我的记忆思路是：

// 咚咚咚，想要最后一个咚，前面如果都要了，就会抖动，防前两个咚，所以防抖：也就是一次触发后，再次触发重新计时。

// 咚咚咚，想要第一个咚，省掉后两个冬，省流，所以节流：也就是一次触发后，再次触发全部忽略。

// # 所以总结

// 防抖和节流，看需求。

// --------------------------
// 😯哦ԅ(¯ㅂ¯ԅ)我又有一个想法：
// *抖防节流

/**
 * -------------------------------------------------
 * *二、突击课hand-云隐
 */
// *1.防抖 => 什么是防抖？ => 场景：一些点击请求上
//     1）函数可以使事件被触发n秒之后再进行处理
//     2) n秒内事件再次被触发则重新计时

// ---------------------
// 防抖函数的实现
// 输入：防抖函数fn；等待的秒数
// 输出：函数的执行
function debounce(fn, wait) {
  // 1. 需要一个定时器
  let timer = null

  return function () {
    let _this = this,
      args = arguments

    // 3. 中途如果再次触发，则清空重新计时
    if (timer) {
      clearTimeout(timer)
      timer = null
    }

    // 2. 将定时器设置成指定间隔时间后执行
    timer = setTimeout(() => {
      fn.apply(_this, args)
    }, wait)
  }
}

// *2.节流的概念
// 节流指的是规定的一个时间，触发一次之后，如果在规定的时间内重复被触发了，只有一次是生效的。
// => 场景：节流使用在scroll函数的事件监听

// ---------------------
// 节流函数的实现
// 输入：节流函数fn；节流延时
// 输出：函数的执行
function throttle(fn, delay) {
  // 1. 获取执行时间的时间点
  let currentTime = Date.now()

  return function () {
    // 3. 获取当前时间点
    let nowTime = Date.now()
    let _this = this,
      args = arguments

    // 2. 两次重复操作的时间间隔与节流延时的关系
    if (nowTime - currentTime >= delay) {
      currentTime = Date.now()
      return fn.apply(_this, args)
    }
  }
}
